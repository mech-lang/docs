Introduction
==============================================================================

1. Welcome to Mech!
------------------------------------------------------------------------------

Hello and welcome to the documentation for Mech, a programming language and system for developing data-driven, reactive systems. Mech authors build programs by defining data dependencies, transformations, and state machines. This makes Mech particularly well-suited for applications that require real-time data processing, such as simulations, visualizations, and interactive systems.

(1.1) A quick example: FizzBuzz

FizzBuzz is a classic programming exercise that can be expressed very concisely in Mech:

```mech
  x := 1..=10               -- Create a row vector of numbers from 1 to 10
  ~out<[string]> := x       -- Create a mutable row vector strings from x
  
  ix2 := (x % 2) == 0       -- Create indices for multiples of 2
  ix3 := (x % 3) == 0       -- Create indices for multiples of 3
  
  out[ix2] = "üêù"           -- Replace multiples of 2 with "üêù"
  out[ix3] = "‚ú®"           -- Replace multiples of 3 with "‚ú®"
  out[ix2 & ix3] = "‚ú®üêù"  -- Replace multiples of both with "‚ú®üêù"
  
  io/println(out)           -- Print the results
```

This short example demonstrates several key features of the language:

- The syntax is concise, expressive and flexible, without the need for keywords and semicolons. In general, Mech programs should be much shorter than equivalent programs in other languages.
- Logical indexing manipulates elements of vectors based on conditions, a declarative way to express iteration and choice, which lends to parallel execution.
- Operations are broadcast elementwise across vectors without needing to write loops, which allows for more efficient execution and automatic vectorization resulting code.
- Type inference is used to determine the types of variables and expressions, so you don't have to specify types explicitly.
- Variable updates are expressed declaratively and without side effects, they can be scheduled to run in parallel.

(1.2) Why Mech?

As computer systems move into the 21st century, we are witnessesing an explosion of computational power and data availability. With the proliferation of multicore processors, GPUs, robots, sensors, and actuators, computer systems are not just becoming more interconnected, but they are also interacting with and respoding to the physical world in real-time. 

Languages of the past (like C, C++, and Python) were designed for a different era of computing, where the focus was on writing imperative code that ran from start to finish on a single core, on a single machine, with limited memory, and batch input and output. Today's machines are multi-core, multi-processor, with GPUs; a variety of asynchronous input devices like keyboards, touch, and pen; a variety of sensors ranging from cameras, to gyroscopes, to LIDAR; and a variety of actuators ranging from servos, to speakers, to displays, to robot arms and legs. 

These machines are not just running programs, they're interacting with the world in real time and continuously processing vast amounts of data. Traditionally, programming languages have handled this complexity by layering on libraries, frameworks, and middleware. This approach often results in adding significant incidental complexity to your project[^1]. 

Mech takes a different approach. Rather than bolting asynchronous behavior onto an imperative core, Mech is built around a reactive, declarative model where data and events are first-class. Relationships are expressed directly, so the flow of information is clear and automatic. This reduces the need for manual state management or explicit coordination between components, letting you describe what your system should do, not how to orchestrate it step by step.

(1.3) Is Mech for you?

Mech is for you if:

-(üìä) You'd like to make an interactive visualization of your data and host it on the internet or in a native desktop application.
-(üéÆ) You're a game designer who wants to build a game that requires networking and real-time data processing for multiplayer interactions.
-(üßë‚Äçüé®) You're an artist who is not a programmer, but would like to create interactive installations or generative art.
-(ü§ñ) You're an engineer who want to build a device or robot that interacts with the real-world via embedded microcontrollers, sensors, and actuators.
-(üßë‚Äçüè´) You're an educator who doesn't really program, but you'd like to use animations and visualizations to teach concepts in math, science, or art.
-(üßë‚Äçüî¨) You're a researcher and you want to build a simulation or model of a complex system, and you'd like to distribute it on the web, the desktop, or embed it inside of your journal paper.
-(üßë‚Äçüíª) You're a developer who wants to build GPU accelerated applications that work natively across windows, mac, linux, and the web.

3. Programming Systems
-------------------------------------------------------------------------------

Whereas traditional languages provide only syntax and a runtime, Mech comes with integrated tools for data transformation, distribution, monitoring, and optimization. As a result, you can focus on defining system behavior rather than managing infrastructure, enabling faster, more reliable development of complex, interconnected systems.

(3.1) Overview

The Mech programming system consists of four parts:

1. **A data description language**, which allows you to define the structure of your data and how it can be transformed.
2. **A reactive programming model**, based on state machines, which allows authors to write systems that can take advantage of asynchrouns and parallel program execution. (WIP)
3. **A distributed execution engine**, which allows you to run Mech programs across multiple machines in a variety of environments, including CPUs, GPUs, embedded devices, and the web. (WIP)
4. **A rich set of "machines"**, libraries, tools, and data sources which provide a wide range of functionality, including data visualization, machine learning, simulation, and more. (WIP)

(3.2) Tools

- `mech` - the Mech programming language toolchain, which includes:
    - a parser and compiler for the text-based Mech syntax
    - a runtime for executing Mech programs
    - a REPL (Read-Eval-Print Loop) for interactive programming
    - a formatter for formatting Mech code into canonical style or HTML documentation.
    - a server for serving Mech programs to a wasm client
    - a Language Server Protocol (LSP) implementation
- `mech-wasm` - a wasm-based client for running Mech programs in the browser or other wasm environments.
- `mech-notebook` - a notebook editor for Mech that runs natively on Windows, macOS, and Linux, and also supports running in the browser via `mech-wasm`.

4. About this Documentation
-------------------------------------------------------------------------------

This documentation is designed to help you get started with Mech, understand its core concepts, and provide guidance on how to use the language effectively. It is structured as follows:

1. **Getting Started**: an introduction to Mech, how to install it, and how to build and run Mech programs. It also covers the Mech REPL (Read-Eval-Print Loop) for interactive programming.
2. **Reference**: a detailed reference for the Mech language, including its data model, programming model, system model, standard library, and Mechdown reference.
3. **Guides**: provides practical guides and tutorials for using Mech, including a quick introduction to the language, tutorials for specific use cases, and guides for developers coming from other programming languages.
4. **Design Documents**: information on the design principles behind Mech, including the language specification, design principles, syntax design notes, and the roadmap for future development, as well as the history of the language.

**Note** - This documentation is written in Mechdown, a lightweight markup language that is compatible with Mech. This means that each document is a valid Mech program that can be executed.

5. Getting Involved
-------------------------------------------------------------------------------

The Mech community stays active at a few places around the Internet:

-(üëæ) [Discord](https://discord.gg/asqP25NNTH) - for live chat
-(üêô) [GitHub](https://github.com/mech-lang) - for code and issues
-(üì∫) [YouTube](https://www.youtube.com/@MechLang) - for video tutorials
-(üõ∏) [Reddit](https://www.reddit.com/r/mechlang/) - for help and general discussion
-(üìß) [Mailing List](https://groups.google.com/g/mechtalk) - for dev discussion

[^1]: A well-known example is "callback hell," where the imperative model struggles to express relationships between data and events. As a result, developers are forced to chain callbacks, promises, and event handlers in convoluted ways, making the code harder to read, reason about, and maintain.