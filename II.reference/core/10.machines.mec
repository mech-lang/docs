Machines
==========

Machines form the modularity system in Mech, providing reusable components such as functions, asynchronous functions, and data tables.

Features
----------

- Functions, asynchronous functions, and data tables.
- Automatic download and resolution of dependencies.
- Compile functions from other languages (e.g., Rust) or use native Mech functions.
- No need for explicit import or configuration, but specifying dependencies and their versions is supported.

Usage
-------

(1) Importing

To use a function or table provided in a Machine, reference it in your code. Mech will automatically resolve the dependencies if it can find the Machine in the Mech Machine Repository. If not, you can manually add the Machine to a the `machines` folder of your program workspace.

(2) Machine Registry

Mech maintains a registry of available Machines for easy discovery and management. The registry is currently hosted <a href="https://gitlab.com/mech-lang/machines/mech/-/raw/v0.1-beta/src/registry.mec">here</a>, and you are free to use a custom registry in place or in addition to the official registery. 

Creating Machines
-------------------

(1) Machine Structure

A Machine can contain cores, blocks, functions (both synchronous and asynchronous), data tables, and binary assets (media, AI models, etc.) that can be imported into Mech programs.

(2) Mech-native

Machines can include native Mech functions, which are written in Mech and can be used directly in the language. See the Functions section of the documentation for more information.

(3) Foreign Function Interface (FFI)

Machines can also include functions written in other languages (e.g., Rust, JavaScript) that are compiled into Mech-compatible form. 

(a) Rust

Rust functions can be made Mech-compatible by implementing the `MechFunction` and `MechFunctionCompiler` traits, or the Machine trait.


```rust
pub trait MechFunction {
  fn solve(&self);
  fn to_string(&self) -> String;
}
```

```rust
pub trait MechFunctionCompiler {
  fn compile(&self, 
    block: &mut Block, 
    arguments: &Vec<Argument>, 
    out: &Out) -> std::result::Result<(),MechError>;
}
```

Asynchronous Machines can implement the `AsynchMechFunction` trait.

```rust
pub trait AsynchMechFunction {
  fn name(&self) -> String;
  fn id(&self) -> u64;
  fn on_change(&mut self, table: &Table) -> Result<(), MechError>;
}
```

The resulting Rust code can be compiled into a dynamic library for use in Mech programs. See the following machines for examples:

- set (example of a machine that provides synchronous functions)
- timer (example of a machine that provides asynchronous functions)


(c) JavaScript

Functions written in JavaScript can also be integrated into Mech through WebAssembly.