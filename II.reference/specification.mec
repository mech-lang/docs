Mech Language Specification 
===============================================================================

1. Introduction
-------------------------------------------------------------------------------

This document specifies the default syntax of the Mech programming system, which is designed for developing reactive systems like robots, games, and user interfaces. The syntax specified herein is one of many possible syntaxes and interfaces for Mech, but it may be thought of as the default texual representation of Mech.

This specification starts by defining the most atomic elements of the language, and then builds up to more complex structures.

This document is for:

- Language designers who want to implement a parser for Mech.
- Tool developers who want to build tools that work with Mech code.
- Developers who want to understand the syntax and structure of Mech programs.

2. Source Code Representation
-------------------------------------------------------------------------------

(a) File Format

Mech source code can be stored in files with either the `.mec` or `.ü§ñ` extension. 

Source code is ecoded with UTF-8, which allows for Unicode support directly in the code. This choice has several benefits:

- Makes code more accessible to non-English speakers
- Enables domain experts to use notation from their fields directly in code
- Allows for more expressive and intuitive naming conventions
- Supports mathematical notation that closely resembles standard written forms

(b) Literate Programming and Mechdown

Literate programming, introduced by Donald Knuth, presents programs as structured documents where explanations take precedence over code. In Mech, we support this concept through a format called Mechdown, a superset of Markdown with extensions to support embedded Mech syntax. This document is formatted with Mechdown to demonstrate how it is used.

For more information, see the <a href="#58856088105263747">Mechdown Section</a>.

(c) Whitespace

Whitespace in Mech is used to separate tokens and is generally ignored. This includes spaces, tabs, and newlines. However, whitespace can be significant in certain contexts:

- In lists, whitespace is used to separate items.
- In matrix and table definitions, whitespace deliniates columns and rows.
- In formulas, whitespace is required around operators.

Semicolons and commas are treated as whitespace in most cases. Except in these contexts:

- Semicolons can be used to separate statements so they can be written inline.
- Semicolons can be used in a matrix to separate rows, so they can be written inline.

For more information, see the <a href="">Whitespace design document</a>.

3. Lexical Elements
-------------------------------------------------------------------------------

(a) Tokens

Tokens are the smallest units of meaning in Mech. They include letters, digits, punctuation, and special symbols.

Some Unicode characters are reserved for box drawing, and therefore are excluded from includsion in valid identifiers.

```
alpha = "a".."z" | "A".."Z";
digt = "0".."9";
emoji := emoji-grapheme+ ;
word := alpha+ ;
digit1 := digit+ ;
digit0 := digit* ;
bin-digit := "0" | "1" ;
hex-digit := digit | "a" .. "f" | "A" .. "F" ;
oct-digit := "0" .. "7" ;
number := digit1 ;
```

(b) Identifiers

```
identifier := (alpha | emoji), (alpha | digit | symbol | emoji)* ;
```

Identifiers start with letters or most UTF-8 encoded emoji characters, and can contain alphanumeric, most emojis, /, \*, +, -, and ^ characters.

**Examples:**

  Hello-Word
  io/stdout
  Œîx^2
  ü§ñ
  A*

(c) Keywords

There are only two keywords in Mech:

```
true
false
```

Combined with Mech's Unicode support, this allows users to write code in their native language without the need to learn English keywords.

(c) Operators and Punctuation

Punctutation:
```
. ! ? , : ; ' "
```

Symbols:
```
& | @ / # = \ ~ + - * ^ _
```

Grouping symbols:
```
( ) < > { } [ ]
```

Operators:
```
:= = += -= *= /= ^=
+ - * / ^ %
>- -<
** ¬∑ ‚®Ø \ ' 
| & xor ‚äï ‚äª ! ¬¨
‚à™ ‚à© ‚àñ ‚àÅ ‚äÜ ‚äá ‚ää ‚äã ‚àà ‚àâ 
.. ..=
!= ¬¨= ‚â† == > < >= ‚â§ ‚â•
=> -> ~>
| ‚îÇ ‚îú ‚îî
```

```
punctuation := period 
      | exclamation 
      | question 
      | comma 
      | colon 
      | semicolon 
      | quote 
      | apostrophe ;
symbol := ampersand 
      | bar 
      | at 
      | slash 
      | hashtag 
      | equal 
      | backslash 
      | tilde 
      | plus 
      | dash 
      | asterisk 
      | caret 
      | underscore ;
grouping-symbol := left-parenthesis 
      | right-parenthesis 
      | left-angle 
      | right-angle 
      | left-brace 
      | right-brace 
      | left-bracket 
      | right-bracket ;
escaped-char := backslash,  symbol | punctuation ;
text := alpha 
      | digit 
      | space 
      | tab 
      | escaped-char 
      | punctuation 
      | grouping-symbol 
      | symbol ;
space-tab := space | tab ;
list-separator := whitespace*, ",", whitespace* ;
```

(d) Comments

```
comment-sigil := "--" | "//" ;
comment := comment-singleline | comment-multiline ;
comment-singleline := ws0, comment-sigil, text+ ;
comment-multiline := whitespace*, "/*", (!"*/", whitespace* | text)+, "*/" ;
```

**Examples:**

  -- Single line comment.
  // Also a single line comment.
  /* A multi-line comment.
     It can span multiple lines. */

4. Literals
-------------------------------------------------------------------------------

```
literal := (number | string | atom | boolean | empty), kind-annotation? ;
```

(a) Integers

```
number := number := real-number, "i"? | ("+", real-number, "i")? ;
integer-literal := digit+;
decimal-literal := "0d", <digit+> ;
binary-literal := "0b", <bin-digit+> ;
octal-literal := "0o", <oct-digit+> ;
hexadecimal-literal := "0x", <hex-digit+> ;
```

An integer literal is a sequence of digits representing a whole number. Mech supports decimal, binary, octal, and hexadecimal integer literals, each distinguished by a unique prefix:

- Decimal: A sequence of digits without a prefix (e.g., 42, 123456).
- Binary: Prefixed with 0b, containing only 0 and 1 (e.g., 0b1010).
- Octal: Prefixed with 0o, containing digits 0-7 (e.g., 0o755).
- Hexadecimal: Prefixed with 0x, containing digits 0-9 and a-f or A-F (e.g., 0x1A3F).

**Examples:**

  42
  0b1010
  0o755
  0x1A3F

(b) Floats

```
float-literal := "."?
      , digit+
      , "."?
      , digit* ;
rational-literal := integer-literal
      , slash
      , integer-literal ;
scientific-literal :=  (float-literal | integer-literal)
      , ("e" | "E")
      , plus?
      , dash?
      , (float-literal | integer-literal) ;
```

**Examples:**

  3.14
  0.001
  2.5e10
  1/3     // Rational literal
  1 / 3   // NOT a rational literal, but a division operation

(c) Strings

```
string := quote, (!quote, text)*, quote ;
```

**Examples:**

  "Hello, World!"
  "characters like \" and \\ are escaped with, \\ e.g. \\\""

(d) Boolean

```
boolean := true-literal | false-literal ;
true-literal := english-true-literal | true-symbol ;
false-literal := english-false-literal | false-symbol ;
true-symbol := "‚úì" ;
false-symbol := "‚úó" ;
english-true-literal := "true" ;
english-false-literal := "false" ;
```

**Examples:**

  true
  false
  ‚úì
  ‚úó

(e) Atoms

```
atom := "`", identifier ;
```

**Examples:**

  `A
  `MyAtom
  `MyAtom123
  `üê¶

(f) Empty

```
empty := underscore+ ;
```

**Examples:**

  _

(g) Kinds

```
kind-annotation := left-angle, kind, right-angle ;
kind := kind-fxn 
      | kind-empty 
      | kind-atom 
      | kind-tuple 
      | kind-scalar 
      | kind-bracket 
      | kind-map 
      | kind-brace ;
kind-empty := underscore+ ;
kind-atom := "`", identifier ;
kind-map := "{"
      , kind
      , ":"
      , kind
      , "}" ;
kind-fxn := "("
      , list0(list-separator, kind)
      , ")"
      , "="
      , "("
      , list0(list-separator, kind)
      , ")" ;
kind-brace := "{"
      , list1(",", kind)
      , "}"
      , ":"?
      , list0("," , literal) ;
kind-bracket := "["
      , list1(",",kind)
      , "]"
      , ":"?
      , list0(",", literal) ;
kind-tuple = "("
      , list1(",",kind)
      , ")" ;
kind-scalar := identifier ;
```

**Examples:**
  
  <_>
  <`A>
  <{A:B}>
  <(A,B)=(C,D)>
  <{A,B,C}>
  <[A,B,C]>
  <(A,B,C)>
  <A>
  
5. Data Structures
-------------------------------------------------------------------------------

```
structure := empty_set 
      | empty_table 
      | table 
      | matrix 
      | tuple 
      | tuple_struct 
      | record 
      | map 
      | set ;
```

Data structures in Mech can be broadly classified into two categories: ordered collections that allow duplicated elements, and unordered collections that do now allow duplicated elements.

**Ordered elements, duplicates allowed**
    - Vector (Nx1)
    - Row Vector (1xN)
    - Matrix (N-D)
    - Tuple

**Unordered elements, no duplicates**
    - Record
    - Table
    - Set
    - Map

Each data structure has its own semantics, which will be described in this section.

(a) Matrix

```
matrix_column := space_tab*
      , expression
      , (space_tab*, ("," | table_separator)?, space_tab*) ;
matrix_row := table_separator?
      , space_tab*
      , matrix_column+
      , semicolon?
      , new_line?
      , (box_drawing_char+, new_line)? ;
matrix := matrix_start
      , (box_drawing_char | whitespace)*
      , matrix_row*
      , box_drawing_char*
      , matrix_end ;
```

A matrix is a numbered sequence of elements of a single kind, arranged in rows and columns. The number of elements is called the length of the matrix and is never negative. The number of rows and columns is called the shape of the matrix. The shape is always a pair of non-negative integers. 

The shape is part of the matrix's kind; it must evaluate to a non-negative constant representable by a tuple of kind `(index,index)`. The shape of matrix `A` can be discovered using the built-in function `matrix/shape()`. The elements can be addressed by index indices `(1,1)` through `matrix/shape(A)`. 

Matrix kinds are always two-dimensional, so row vectors and column vectors are also represented as matrices with a single row or column, respectively.

**Examples:**

  -- 3x3 Matrix
  [1 2 3
   4 5 6
   7 8 9]

  -- 3x2 Matrix
  [1, 2; 3, 4; 5, 6]

  -- 1x3 Row Vector
  [1 2 3]

  -- 3x1 Column Vector
  [1
   2
   3]
  
  -- 4x1 Column Vector
  [1; 2; 3; 4]

Fancy matrix syntax is supported so that formatted output from the Mech REPL can be used as program source or input.

```
‚îè           ‚îì
‚îÉ 1   2   3 ‚îÉ
‚îÉ 4   5   6 ‚îÉ
‚îó           ‚îõ
```

The elements of a matrix are indexed in the following ways:

- **1D** - by their position in the matrix, starting from 1, in a column-major order starting at the top left corner of the matrix and proceeding down and to the right. The last element of the matrix, called the end of the matrix, is the most bottom right element.

- **2D** - by the row and column index, starting from 1 for each.

Negative indices indicate counting from the end of the matrix. For example, `-1` is the last element, `-2` is the second to last element, and so on.

(b) Set

```
set := "{"
      , whitespace*
      , list0(("," | whitespace+)
      , expression)
      , whitespace*
      , "}" ;
empty_set := table_start
      , whitespace*
      , empty
      , whitespace*
      , table_end ;
```

**Examples:**

  {1, 2, 3}

(c) Map

```
map := "{"
      , whitespace*
      , mapping*
      , whitespace*
      , "}" ;
mapping :=  whitespace*
      , expression
      , whitespace*
      , ":"
      , whitespace*
      , expression
      , comma?
      , whitespace* ;
```

(d) Tuple

```
tuple := "(", list0(",", expression), ")" ;
tuple_struct = atom, "(", expression, ")" ;
```

**Examples:**

  ()                 
  (1)                
  (1,1,3)                
  (1,(2,3))                
  (1, true, "Hello")
  ([1, 2; 3, 4], 7, false)
  ()                 

(e) Table

```
table := table_start
      , (box_drawing_char | whitespace)*
      , table_header
      , (box_drawing_char | whitespace)*
      , table_row+
      , box_drawing_char*
      , whitespace*
      , table_end ;
binding := identifier
      , kind_annotation?
      , colon
      , expression
      , ","? ;
table_column := space_tab*
      , expression
      , (space_tab*
      , ("," | table_separator)?
      , space_tab*) ;
table_row := table_separator?
      , space_tab*
      , table_column+
      , semicolon?
      , new_line?
      , (box_drawing_char+, new_line)? ;
table_header := list1(space_tab+, field)
      , space_tab*
      , (bar | box_vert)
      , whitespace* ;
field := identifier, kind_annotation? ;
empty_table := table_start
      , whitespace*
      , table_end ;
```

**Examples:**

  { x<f32>  y<u8> | 
    1.2     9 
    1.3     8     }

(f) Record

```
record := table_start
      , whitespace*
      , binding+
      , whitespace*
      , table_end ;
```

**Examples:**

  { x: 1 y: "a", z: [1 2 3] }
  { x<u8>: 1, y<string>: "a", z<[u8]:3,1>: [1;2;3] }
  { a: {b: 1, c: "hi"}, b: [1;2;3] }

6. Expressions
-------------------------------------------------------------------------------

```
expression := range-expression | formula ;
```

(a) Formula 

```
parenthetical-term := left-parenthesis, formula, right-parenthesis ;
negate-factor := "-", factor ;
not-factor := "not", factor ;

formula := l1, (range_operator, l1)* ;
add_sub_operator := add | subtract ;
l1 := l2, (add_sub_operator, l2)* ;
mul_div_operator := multiply | divide ;
matrix_operator := matrix_multiply 
      | multiply 
      | divide 
      | matrix_solve ;
l2 := l3, (mul_div_operator | matrix_operator, l3)* ;
exponent_operator := exponent ;
l3 := l4, (exponent_operator, l4)* ;
logic_operator := and 
      | or 
      | xor ;
l4 := l5, (logic_operator, l5)* ;
comparison_operator := not_equal 
      | equal_to 
      | greater_than_equal 
      | greater_than 
      | less_than_equal 
      | less_than ;
l5 := factor, (comparison_operator, factor)* ;

factor := (parenthetical_term 
      | structure 
      | fsm_pipe 
      | function_call 
      | literal 
      | slice 
      | var), transpose? ;
```

(a) Arithmetic

```
+    add               integers, floats, complex values, strings
-    subtract          integers, floats, complex values
*    multiply          integers, floats, complex values
/    divide            integers, floats, complex values
^    exponent          integers, floats, complex values
%    remainder         integers
```

(b) Matrix

```
\              solve          
¬∑              dot product    
‚®Ø              cross product  
**             matrix multiply
'              transpose      
```

(c) Comparison

```
!= | ¬¨= | ‚â†    not equal       
==             equal                 
>              greater         
<              less            
>= | ‚â•         greater or equal
<= | ‚â§         less or equal   
```

(d) Logical

```
|              or
&              and
! | ¬¨          not
xor | ‚äï | ‚äª   exclusive or
```

(e) Set

```
‚à™       union
‚à©       intersection
‚àñ       difference
‚àÅ | '   complement
‚äÜ       subset
‚äá       superset
‚ää       proper subset
‚äã       proper superset
‚àà       element of
‚àâ       not element of
```

(f) Range

```
..=     range inclusive
..      range exclusive
```

7. Indexing
-------------------------------------------------------------------------------

```ebnf
subscript := swizzle-subscript 
      | dot-subscript-int 
      | dot-subscript 
      | bracket-subscript 
      | brace-subscript ; 
index := identifier, +subscript ;
```

(a) Slicing

```ebnf
bracket-subscript := "["
      , [(select-all | range-subscript | formula-subscript), ","]
      , "]" ;

brace-subscript := "{"
      , [(select-all | formula-subscript), ","]
      , "}" ;
formula-subscript := formula ;
range-subscript := range-expression ;
select-all := ":" ;
```
**Examples**
    array := [10, 20, 30, 40, 50]
    slice_1 := array[1:]                -- Select all from index 1 to the end (select-all)
    slice_2 := array[1, 3]              -- Range subscript (from index 1 to 3)
    slice_3 := array[2, 4]              -- Another range from index 2 to 4
    slice_4 := array[:4]                -- Select all up to index 4
    slice_formula := array[(x + y), 3]  -- Formula-based subscript, with a calculated index

    matrix := { {1, 2}, {3, 4}, {5, 6} }
    brace_index := matrix{(x * y)}      -- Formula-based indexing within braces


(b) Dot Index

```ebnf
dot-subscript := ".", identifier ;
dot-subscript-int := ".", integer-literal ;
```
**Examples**
    dot_result_1 := object.field        -- Dot subscript with identifier
    dot_result_2 := object.42           -- Dot subscript with integer literal

(c) Swizzle

```ebnf
swizzle-subscript := "."
      , identifier
      , "," 
      , [identifier, ","] ;
```
**Examples:**
    vector := {x: 1, y: 2, z: 3}
    swizzle_result := vector.x, y      -- Swizzling: selecting x and y
    swizzle_combined := vector.x, y, z -- Swizzling: selecting x, y, z


8. Statements
-------------------------------------------------------------------------------

```ebnf
statement := variable-define 
      | variable-assign 
      | enum-define 
      | fsm-declare 
      | kind-define ;
```

(a) Variable Define

```ebnf
define-operator := ":=" ;
variable-define := ?tilde, var
      , ¬¨assign-operator
      , define-operator
      , expression ;
```
**Examples** 
    intVar := 10                                -- Variable definition with initialization
    optionalVar := ~stringVar                   -- Variable definition with optional tilde
    varWithExpression := ~calculatedValue * 5   -- Variable definition with expression

(b) Variable Assign

```ebnf
assign-operator := "=";
variable-assign := slice-ref
      , ¬¨define-operator
      , assign-operator
      , expression ;
```
**Examples**
    numbers := [1, 2, 3, 4, 5]
    numbers[2] = 10             -- Assign value 10 to index 2 of the array

(c) Op-Assign

```ebnf
add-assign-operator := "+=";
sub-assign-operator := "-=";
mul-assign-operator := "*=";
div-assign-operator := "/=";
exp-assign-operator := "^=";
op-assign-operator := add-assign-operator 
      | sub-assign-operator 
      | mul-assign-operator 
      | div-assign-operator 
      | exp-assign-operator ;
op-assign := slice-ref
      , ¬¨define-operator
      , op-assign-operator
      , expression ;
```
**Examples**
    counter := 0
    counter += 5                 -- Add 5 to counter (addition assignment)
    counter -= 3                 -- Subtract 3 from counter (subtraction assignment)
    counter *= 2                 -- Multiply counter by 2 (multiplication assignment)
    counter /= 4                 -- Divide counter by 4 (division assignment)
    counter ^= 2                 -- Exponentiate counter by 2 (exponentiation assignment)

(c) Enum Define

```ebnf
enum-define := "<"
      , identifier, ">"
      , define-operator
      , [enum-variant, enum-separator];
enum-variant := ?grave
      , identifier
      , ?enum-variant-kind ;
enum-variant-kind := "("
      , kind-annotation
      , ")" ;
```
**Examples**
    status < Active | Inactive | Pending  -- Enum definition with variants
    priority < High | Medium | Low        -- Enum definition for priority levels

(d) Kind Define

```ebnf
kind-define := "<"
      , identifier
      , ">"
      , define-operator
      , kind-annotation ;
```
**Examples**
    userKind < Person > :< string | int -- Kind definition with annotation

9. Functions
-------------------------------------------------------------------------------

(a) Function Define

```ebnf
function-define := identifier
      , "("
      , ?[function-arg,list-separator]
      , ")"
      , "="
      , (function-out-args | function-out-arg)
      , define-operator
      , [statement, (+whitespace | statement-separator)]
      , "." ;
function-out-args := "("
      , [function-arg, list-separator]
      ,")" ;      
function-out-arg := function-arg ;
function-arg := identifier, kind-annotation ;
argument-list := "(", ?[(call-arg-with-biding | call-arg), ","], ")" ;
```

**Examples**

    -- Simple function definition with no return value
    addNumbers(x: int, y: int) = (result: int) := 
        result = x + y
        .  -- Return result (implicitly)

    -- Function with multiple output arguments
    createRectangle(length: int, width: int) = (area: int, perimeter: int) := 
        area = length * width
        perimeter = 2 * (length + width)
        .  -- Return both area and perimeter

    -- Function with an optional argument (no output)
    greetUser(name: string) = := 
        print("Hello, " + name)
        .  -- No output, just side-effect

    -- Function with complex arguments and output
    calculateStats(x: int, y: int, z: int) = (average: float, max: int) := 
        average = (x + y + z) / 3.0
        max = max(x, max(y, z))  -- Function calls inside function body
        .  -- Return both average and max


(b) Function Call

```ebnf
function-call := identifier, argument-list ;
call-arg-with-binding := identifier
      , colon
      , expression ;
call-arg := expression ;
var := identifier, ?kind-annotation ;
```
**Examples**
    -- Call function with simple arguments
    sumResult = addNumbers(5, 10)   -- Call addNumbers with two integer arguments

    // Call function with binding (using colon syntax to bind a specific argument)
    rectangleDetails = createRectangle(10, 20)  -- Call with two integers
    area = rectangleDetails.area                -- Accessing the area
    perimeter = rectangleDetails.perimeter      -- Accessing the perimeter

    // Call function with complex arguments and output
    stats = calculateStats(10, 20, 30)          -- Call calculateStats
    average = stats.average                     -- Extract average
    maxValue = stats.max                        -- Extract max value

    // Call function with optional argument
    greetUser("Alice")      -- Function call with a single string argument

10. State Machines
-------------------------------------------------------------------------------

```ebnf
fsm := "#"
      , identifier
      , ?argument-list
      , ?kind-annotation ;
```

(a) Operators

```ebnf
output-operator := "=>" ;
transition-operator := "->" ;
async-transition-operator := "~>" ;
guard-operator := "|" 
      | "‚îÇ" 
      | "‚îú" 
      | "‚îî" ;
```

(b) Specification

```ebnf
fsm-specification := "#"
      , identifier
      , "("
      , ?[var, ","]
      , ")"
      , ?output-operator
      , ?kind-annotation, define-operator, +fsm-state-definition, "." ;
fsm-tuple-struct := grave
      , identifier
      , "("
      , [fsm-pattern, ","]
      , ")" ;
fsm-state-definition := guard-operator
      , grave
      , identifier
      , ?fsm-state-definition-variables ;
fsm-state-definition-variables := "("
      , ?[var, list-separator]
      , ")" ;
fsm-pipe := fsm-instance, *(fsm-state-transition | fsm-async-transition | fsm-output) ;
fsm-declare := fsm
      , define-operator
      , fsm-pipe ;
fsm-instance := "#"
      , identifier
      , ?fsm-args ;
fsm-args := "("
      , ?[(call-arg-with-binding | call-arg), list-separator]
      , ")" ;
```

(c) Implementation

```ebnf
fsm-implementation := "#"
      , identifier
      , "("
      , ?[identifier, list-separator]
      , ")"
      , transition-operator
      , fsm-pattern
      , *whitespace
      , +fsm-arm
      , "." ;
fsm-arm := *comment
      , (fsm-transition | fsm-guard-arm)
      , *whitespace ;
fsm-guard-arm := *comment
      , fsm-pattern
      , +fsm-guard ;
fsm-guard := guard-operator
      , fsm-pattern
      , +(fsm-statement-transition | fsm-state-transition | fsm-output | fsm-async-transition | fsm-block-transition) ;
fsm-transition := *comment
      , fsm-pattern
      , +(fsm-statement-transition | fsm-state-transition | fsm-output | fsm-async-transition | fsm-block-transition) ;
fsm-state-transition := transition-operator, fsm-pattern ;
fsm-async-transition := async-transition-operator, fsm-pattern ;
fsm-statement-transition := transition-operator, statement ;
fsm-block-transition := transition-operator
      , left-brace
      , +mech-code
      , right-brace ;
fsm-output := output-operator, fsm-pattern ;
fsm-pattern := fsm-tuple-struct 
      | wildcard 
      | formula ;
wildcard := "*" ;
```
**Examples**
    -- Simple FSM Declaration
    fsm SimpleFSM
        (var1, var2)         -- Variables for FSM
        =>                   -- Output operator
        ;                    -- End of the state machine definition

    -- FSM with states and transitions
    fsm StateMachine1
        (state1, state2)
        => "StateMachineOutput"   -- Output operator for the FSM
        kind "simple"
        define
        #state1
            -> state2    -- Transition operator
            | guard1     -- Guard operator for conditional transitions
        .

    fsm-instance MyFSM
        (stateA, stateB)
        -> stateB         -- Simple state transition
        ~> stateA         -- Asynchronous transition operator


    -- FSM with variables and multiple states
    fsm ComplexFSM
        (state1, state2, state3)
        => "Processing"
        define
        #state1
            -> state2    -- Transition from state1 to state2
        | state2
            -> state3    -- Transition from state2 to state3
            ~> state1    -- Asynchronous transition back to state1
        .

    fsm-instance ComplexFSMInstance
        (stateX, stateY, stateZ)
        -> stateX       -- Transition to stateX
        ~> stateY       -- Async transition to stateY
        => outputX      -- FSM Output
        .


    -- FSM with guards and output operators
    fsm-implementation MyFSMImpl
        #FSMTransition1
        (state1, state2)
        -> state3         -- Transition from state1 to state3
        => stateOutput    -- Output from this FSM transition
        .

    fsm-guard-arm MyFSMGuard
        #FSMGuardState
        (stateGuard)
        | guard-condition  -- Guard operator for conditional checking
        .

    fsm-guard MyFSMGuardExample
        | FSMGuardPattern
        -> FSMGuardTransition
        ~> FSMAsyncGuard
        .

    fsm-block-transition MyFSMBlockTransition
        -> {
            // Complex code block executed during state transition
            set stateA = true
            set stateB = false
        }
        .


    -- FSM pattern with tuple struct
    fsm-pattern MyFSMPattern
        grave TupleState
        (varA, varB)
        .


    -- FSM instance with arguments
    fsm-instance ComplexArgsFSM
        (stateStart, stateEnd)
        (inputData1, inputData2) -- Call arguments with bindings
        -> stateStart
        .


    -- FSM State definition with guard and pattern matching
    fsm-state-definition MyStateDefinition
        | stateGuard
        grave stateDefinition
        (variableX, variableY)
        .


    -- FSM with wildcards and formulas in patterns
    fsm-pattern MyWildcardPattern
        *
        .

    fsm-pattern MyFormulaPattern
        formula("x + y = 10")
        .

11. Mech Programs
-------------------------------------------------------------------------------

```ebnf
mech := program | statement ;
```

(a) Programs

```ebnf
program := ?title, body ;
body := +section ;
```
**Examples**
    -- Mech Program

    ```mech
    -- Program starts with an optional title

    program MyProgram
        -- Body of the program
        section Introduction
            This section explains the purpose of the program.
            -> state1
            .
        section Usage
            This section describes how to use the program.
            - Run `mech-program run` in the terminal.
        .

(b) Sections

```ebnf
section-element := mech-code 
      | unordered-list 
      | comment 
      | paragraph 
      | code-block 
      | sub-section ;
sub-section-element := comment 
      | unordered-list 
      | mech-code 
      | paragraph 
      | code-block;
sub-section := alpha-subtitle, *sub-section-element ;
section := ?ul-subtitle, +section-element ;
```
**Examples**
    -- Mech Program with Sections

    ```mech
    -- A program with sections and sub-sections

    program MechProgram
        section Introduction
            This section provides an introduction to Mech programming.
            - First, define your variables.
            - Second, initialize your FSM.
            - Finally, run your program.
        section Installation
            alpha-subtitle "Step 1"
            - Install Mech interpreter.
            - Download the latest version from the website.
            alpha-subtitle "Step 2"
            - Setup environment variables.
            - Test the installation by running `mech --version`.
        section Example Code
            Here is a simple example of a Mech program:
            ```mech
            fsm SimpleFSM
                (input, output)
                define
                #startState
                    -> nextState
                    => "Example Output"
                .
            ```
        .

12. Mechdown
-------------------------------------------------------------------------------

(a) Markdown

```ebnf
title := +text
      , new-line
      , +"="
      , *(space|tab)
      , *whitespace ;
subtitle := +digit-token
      , "."
      , *space
      , +text
      , new-line
      , +"-"
      , *(space|tab)
      , new-line
      , *(space|tab)
      , *whitespace ;
number-subtitle := *(space|tab)
      , "("
      , integer-literal
      , ")"
      , +(space|tab)
      , +text
      , *(space|tab)
      , *whitespace ;
alpha-subtitle := *(space|tab)
      , "(", alpha, ")"
      , +(space|tab)
      , +text
      , *(space|tab)
      , *whitespace ;
paragraph-element := +(¬¨define-operator, text) ;
paragraph := paragraph-starter, *paragraph-element ;
unordered-list := +list-item, ?new-line, *whitespace ;
list-item := dash
      , +space
      , paragraph
      , *new-line ;
code-block := (grave, grave, grave), new-line, any, (grave, grave, grave), new-line, *whitespace ;
```

(b) Mech Extensions

```ebnf
mech-code := mech-code-alt, ("\n" | ";" | comment) ;
```

**Example**
    -- Title for the Document
    # Title Here
    =========================================

    -- Subtitle with Numbering
    1.Subtitle Here
    -----------------------------------

    -- Alpha Subtitle Example
    (A) Alpha Subtitle
    -------------------------------

    -- Numbered Subtitle with Parentheses
    (1) Num Subtitle w/ Paren
    -------------------------

    -- Unordered List Example
    - First
    - Second
    - Third

    -- Code Block Example with New Lines
    ```mech
    -- Example of a Mech function
    fsm SimpleFSM
        (input, output)
        define
        #state1
            -> state2
            => output

13. Notation
-------------------------------------------------------------------------------

The grammar is specified using extended Extended Backus-Naur Form (EBNF):

| Symbol   | Meaning  | Semantics                     |
|----------|----------|-------------------------------|
| `"abc"`  | terminal | string literal "abc"          |
| `p1, p2` | sequence | `p1` followed by `p2`         |
| `p1 | p2`| choice   | `p1` or `p2`                  |
| `[p, q]` | list     | list of `p` deliniated by `q` |
|   `*p`   | repeat 0 | `p` for 0 or more times       |
|   `+p`   | repeat 1 | `p` for 1 or more times       |
|   `?p`   | optional | `p` for 0 or 1 time           |
|   `>p`   | peek     | `p`; do not consume input     |
|   `¬¨p`   | not      | does not match `p`            |
|  `(...)` | group    | incrase precedence            |


The grammar grammar:

```ebnf
grammar := +rule ;
identifier := alpha-token, *(alpha-token | digit-token | dash) ;
rule := identifier
      , ":="
      , expression
      , ";" ;
expression := term, *( "|", term ) ;
term := factor, *( ",", factor ) ;
definition := identifier ;
repeat0 := "*", factor ;
repeat1 := "+", factor ;
optional := "?", factor ;
peek := ">", factor ;
not := "¬¨", factor ;
list := "[", expression, terminal, "]" ;
factor := repeat0 
      | repeat1 
      | optional 
      | peek 
      | not 
      | list
      | group 
      | definition 
      | terminal ;
group := "(", expression, ")" ;
terminal := quote, +any-token, quote ;
```