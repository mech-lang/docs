Mech Language Specification 
===============================================================================

1. Introduction
-------------------------------------------------------------------------------

This document specifies the default syntax of the Mech programming system, which is designed for developing reactive systems like robots, games, and user interfaces. The syntax specified herein is one of many possible syntaxes and interfaces for Mech, but it may be thought of as the default texual representation of Mech.


This specification starts by defining the most atomic elements of the language, and then builds up to more complex structures.

This document is for:

- Language designers who want to implement a parser for Mech.
- Tool developers who want to build tools that work with Mech code.
- Developers who want to understand the syntax and structure of Mech programs.

2. Source Code Representation
-------------------------------------------------------------------------------

(a) File Format

Mech source code can be stored in files with either the `.mec` or `.ü§ñ` extension. 

Source code is ecoded with UTF-8, which allows for Unicode support directly in the code. This choice has several benefits:

- Makes code more accessible to non-English speakers
- Enables domain experts to use notation from their fields directly in code
- Allows for more expressive and intuitive naming conventions
- Supports mathematical notation that closely resembles standard written forms

(b) Literate Programming and Mechdown

Literate programming presents programs as structured documents where explanations take precedence over code. In Mech, we support this concept through a format called Mechdown, a superset of Markdown with extensions to support embedded Mech syntax. This document is formatted with Mechdown to demonstrate how it is used.

For more information, see the [Mechdown Section](#58856088105263747).

(c) Whitespace

Whitespace in Mech is used to separate tokens and is generally ignored. This includes spaces, tabs, and newlines. However, whitespace can be significant in certain contexts:

- In lists, whitespace is used to separate items.
- In matrix and table definitions, whitespace deliniates columns and rows.
- In formulas, whitespace is required around operators.

Semicolons and commas are treated as whitespace in most cases. Except in these contexts:

- Semicolons can be used to separate statements so they can be written inline.
- Semicolons can be used in a matrix to separate rows, so they can be written inline.

For more information, see the [Whitespace Design Document](#).

3. Lexical Elements
-------------------------------------------------------------------------------

(a) Tokens

Tokens are the smallest units of meaning in Mech. They include letters, digits, punctuation, and special symbols.

Some Unicode characters are reserved for box drawing, and therefore are excluded from includsion in valid identifiers.

```ebnf
alpha := "a".."z" | "A".."Z" ;
digit := "0".."9";
emoji := +emoji-grapheme ;
word := +alpha ;
digit1 := +digit ;
digit0 := *digit ;
bin-digit := "0" | "1" ;
hex-digit := digit | "a" .. "f" | "A" .. "F" ;
oct-digit := "0" .. "7" ;
number := digit1 ;
forbidden-emoji := box-drawing | other-forbidden-shapes ;
emoji := (¬¨forbidden-emoji, emoji-grapheme) ;
```

(b) Identifiers

```ebnf
identifier := (alpha | emoji), *(alpha | digit | symbol | emoji) ;
```

Identifiers start with letters or most UTF-8 encoded emoji characters, and can contain alphanumeric, most emojis, /, \*, +, -, and ^ characters.

**Examples:**

  Hello-Word
  io/stdout
  Œîx^2
  ü§ñ
  A*

(c) Keywords

There are only two keywords in Mech:

```
true
false
```

Combined with Mech's Unicode support, this allows users to write code in their native language without the need to learn English keywords.

(c) Operators and Punctuation

**Punctutation:**
```
. ! ? , : ; ' "
```

**Symbols:**
```
& | @ / # = \ ~ + - * ^ _
```

**Grouping symbols:**
```
( ) < > { } [ ]
```

**Operators:**
```
Assign       := = += -= *= /= ^=
Arithmetic   + - * / ^ %
Split        >- -<
Matrix       ** ¬∑ ‚®Ø \ ' 
Logic        | & xor ‚äï ‚äª ! ¬¨
Set          ‚à™ ‚à© ‚àñ ‚àÅ ‚äÜ ‚äá ‚ää ‚äã ‚àà ‚àâ 
Range        .. ..=
Condition    != ¬¨= ‚â† == > < >= ‚â§ ‚â•
Transition   => -> ~>
Guard        | ‚îÇ ‚îú ‚îî
```

```ebnf
punctuation := period 
      | exclamation 
      | question 
      | comma 
      | colon 
      | semicolon 
      | quote 
      | apostrophe ;
symbol := ampersand 
      | bar 
      | at 
      | slash 
      | hashtag 
      | equal 
      | backslash 
      | tilde 
      | plus 
      | dash 
      | asterisk 
      | caret 
      | underscore ;
grouping-symbol := left-parenthesis 
      | right-parenthesis 
      | left-angle 
      | right-angle 
      | left-brace 
      | right-brace 
      | left-bracket 
      | right-bracket ;
escaped-char := backslash,  symbol | punctuation ;
text := alpha 
      | digit 
      | space 
      | tab 
      | escaped-char 
      | punctuation 
      | grouping-symbol 
      | symbol ;
space-tab := space | tab ;
list-separator := *whitespace, ",", *whitespace ;
```

(d) Comments

```ebnf
comment-sigil := "--" | "//" ;
comment :=  *whitespace
      , comment-sigil
      , +text ;
```

**Examples:**

  -- Single line comment.
  // Also a single line comment.

4. Literals
-------------------------------------------------------------------------------

```ebnf
literal := (number | string | atom | boolean | empty), ?kind-annotation ;
```

(a) Integers

```ebnf
number := real-number, ?"i" | ?("+", real-number, "i") ;
integer-literal := +digit;
decimal-literal := "0d", +digit ;
hexadecimal-literal := "0x", +hex-digit ;
octal-literal := "0o", +oct-digit ;
binary-literal := "0b", +bin-digit ;
```

An integer literal is a sequence of digits representing a whole number. Mech supports decimal, binary, octal, and hexadecimal integer literals, each distinguished by a unique prefix:

- Decimal: A sequence of digits without a prefix (e.g., 42, 123456).
- Hexadecimal: Prefixed with 0x, containing digits 0-9 and a-f or A-F (e.g., 0x1A3F).
- Octal: Prefixed with 0o, containing digits 0-7 (e.g., 0o755).
- Binary: Prefixed with 0b, containing only 0 and 1 (e.g., 0b1010).

**Examples:**

  0d42                -- decimal
  0x1234567890ABCDEF  -- hexadecimal
  0x1234567890abcdef  
  0o12345670          -- octal 
  0b100110101         -- binary

(b) Floats

```ebnf
scientific-literal :=  (float-literal | integer-literal)
      , ("e" | "E")
      , ?plus
      , ?dash
      , (float-literal | integer-literal) ;
rational-literal := integer-literal
      , slash
      , integer-literal ;
float-literal := ?"."
      , +digit
      , ?"."
      , *digit ;
```

**Examples:**
  
  1234
  3.14
  0.001
  2.5e10
  -12.3E4

(c) Strings

```ebnf
string := quote, *(¬¨quote, text), quote ;
```

**Examples:**

  "Hello, World!"
  "characters like \" and \\ are escaped with, \\ e.g. \\\""

(d) Boolean

```ebnf
boolean := true-literal | false-literal ;
true-literal := english-true-literal | true-symbol ;
false-literal := english-false-literal | false-symbol ;
true-symbol := "‚úì" ;
false-symbol := "‚úó" ;
english-true-literal := "true" ;
english-false-literal := "false" ;
```

**Examples:**

  true
  false
  ‚úó
  ‚úì

(e) Atoms

```ebnf
atom := "`", identifier ;
```

**Examples:**

  `A
  `MyAtom
  `MyAtom123
  `üê¶

(f) Empty

```ebnf
empty := +underscore ;
```

**Examples:**

  _

(g) Kinds


```ebnf
kind-annotation := "<", kind, ">" ;
kind := kind-fxn 
      | kind-empty 
      | kind-atom 
      | kind-tuple 
      | kind-scalar 
      | kind-bracket 
      | kind-map 
      | kind-brace ;
kind-empty := +"_" ;
kind-atom := "`", identifier ;
kind-map := "{"
      , kind
      , ":"
      , kind
      , "}" ;
kind-fxn := "("
      , ?[",", kind]
      , ")"
      , "="
      , "("
      , ?[",", kind]
      , ")" ;
kind-brace := "{"
      , [",", kind]
      , "}"
      , ?":"
      , ?[",", literal] ;
kind-bracket := "["
      , [",", kind]
      , "]"
      , ?":"
      , ?[",", literal] ;
kind-tuple := "("
      , [",", kind]
      , ")" ;
kind-scalar := identifier ;
```


5. Data Structures
-------------------------------------------------------------------------------

```ebnf
structure := empty-set 
      | empty-table 
      | table 
      | matrix 
      | tuple 
      | tuple-struct 
      | record 
      | map 
      | set ;
```

Data structures in Mech can be broadly classified into two categories: ordered collections that allow duplicated elements, and unordered collections that do now allow duplicated elements.

**Ordered elements, duplicates allowed**
    - Vector (Nx1)
    - Row Vector (1xN)
    - Matrix (N-D)
    - Tuple

**Unordered elements, no duplicates**
    - Record
    - Table
    - Set
    - Map

Each data structure has its own semantics, which will be described in this section.

(a) Matrix

```ebnf
matrix-column := *space-tab 
      , expression 
      , (*space-tab, ?("," | table-separator), *space-tab) ;
matrix-row := ?table-separator
      , *space-tab
      , +matrix-column
      , ?semicolon
      , ?new-line
      , ?(+box-drawing-char, new-line) ;
matrix := matrix-start
      , *(box-drawing-char | whitespace)
      , *matrix-row
      , *box-drawing-char
      , matrix-end ;
```
A Matrix is a structured, numbered sequence of elements of a single kind, arranged in rows and columns, enclosed bt square brackets, `[]`. The number of elements in the matrix is called its length, and the shape of a matrix is defined as a pair of non-negative integers representing the number of rows and columns.

**Semantics:**

- Homogeneous Elements: All elements in a matrix must be of the same kind.
- Fixed Shape: A static matrix's shape (rows, columns) is part of its kind and is always a tuple of non-negative integers.
- One-Based Access: Elements are accessed using 1-based indexing for both rows and columns.
- Column-Major Order: Matrix elements are stored and accessed in column-major order.

Matrix kinds are always two-dimensional, so row vectors and column vectors are also represented as matrices with a single row or column, respectively.

**Indexing:**

Matrix elements can be accessed using either 1D or 2D indexing:

- 1D Indexing (Column-Major Order): Elements are stored in column-major order, meaning the first element is the top-left element, proceeding down the first column before moving to the next.
- 2D Indexing: Elements can be referenced using `[row, column]` notation, starting from 1 for both indices.
- Negative Indices: Negative indices count from the end of the matrix, with -1 being the last element.

See the Indexing section for more details and examples.

**Examples:**

  -- Empty Matrix
  []

  -- 1x1 Matrix
  [1]

  -- 3x3 Matrix
  [1 2 3
   4 5 6
   7 8 9]

  -- 3x2 Matrix
  [1, 2; 3, 4; 5, 6]

  -- 1x3 Row Vector
  [1 2 3]

  -- 3x1 Column Vector
  [1
   2
   3]
  
  -- 4x1 Column Vector
  [1; 2; 3; 4]

Fancy matrix syntax is supported so that formatted output from the Mech REPL can be used as program source or input.

```
‚îè           ‚îì
‚îÉ 1   2   3 ‚îÉ
‚îÉ 4   5   6 ‚îÉ
‚îó           ‚îõ
```
The elements of a matrix are indexed in the following ways:

- **1D** - by their position in the matrix, starting from 1, in a column-major order starting at the top left corner of the matrix and proceeding down and to the right. The last element of the matrix, called the end of the matrix, is the most bottom right element.

- **2D** - by the row and column index, starting from 1 for each.

Negative indices indicate counting from the end of the matrix. For example, `-1` is the last element, `-2` is the second to last element, and so on.

**Kind**

The kind of a matrix includes the type of its elements and its shape. For example, a matrix of unsigned 8-bit integers with 2 rows and 3 columns has the kind `<[u8]:2,3>`.

```
-- Dynamic matrix        <[u8]>
-- 2D Matrix             <[u8]:2,3>
-- 3D Matrix             <[u8]:2,3,4>
```

(b) Set

```ebnf
set := "{"
      , *whitespace
      , ?[expression, list-separator]
      , *whitespace
      , "}" ;
empty-set := table-start
      , *whitespace
      , empty
      , *whitespace
      , table-end ;
```

A Set is defined using curly braces `{}` and contains a comma-separated list of expressions. Sets do not maintain order and contain only unique elements.

**Semantics:**

- Homogeneity: All elements in a set must be of the same type.
- Unordered: The order of elements within a set is not preserved.
- Uniqueness: Duplicate elements are not allowed in a set.

**Operations:**

- Insertion: Adding an element to a set does not affect its order and only - succeeds if the element is not already present.
- Deletion: Removing an element, if present, maintains the set property.
- Union: Combines two sets, keeping only unique elements.
- Intersection: Produces a set containing elements common to both sets.
- Difference: Returns a set containing elements in the first set but not in the second.

**Examples:**

```
- Empty: `{}` or `{_}`
- Singleton: {1}
- Basic:     {1,2,3}
- Strings:   {"apple", "banana", "cherry"}
- Nested:    {{1,2},{3,4}}
```

**Edge Cases**

- `{}` represents an empty set.
- `{1, 1, 2}` results in `{1, 2}` due to uniqueness constraints.
- `{1, "hello"}` results in a type error due to homogeneity constraints.

**Kind:**

```
<{u8}:3>
```

(c) Map

```ebnf
map := "{", *whitespace, *mapping, *whitespace, "}" ;
mapping :=  *whitespace, expression, *whitespace, ":", *whitespace, expression, ?comma, *whitespace ;
```

A Map is defined using curly braces `{}` and contains a set of key-value mappings. Each key is unique and associated with a corresponding value.

**Semantics:**

- Key Uniqueness: Each key in a map must be unique.
- Unordered: The order of key-value pairs within a map is not preserved.
- Key-Value Association: Each key is mapped to exactly one value.

**Operations**

- Insertion: Adding a key-value pair updates the map. If the key already exists, its value is updated.
- Deletion: Removing a key-value pair removes the key and its associated value.
- Lookup: Retrieving the value associated with a key.
- Merge: Combining two maps, where duplicate keys take precedence from the second map.

```
- Empty:             {_:_}
- Single element:    {"a":1}
- Multiple elements: {"a":10, "b":20, "c": 30}
- Nested:            {"a":{"a":10}}
- Multiline:
    { "a" : 10 
      "b" : 20
      "c" : 30 }
```

**Edge Cases**

- `{_:_}` represents an empty map.
- Duplicate keys result in an overwrite of the previous value, as long as the map is mutable.
- `{1: "hello", 2: "world"}` is valid, but `{1: "hello", "one": "world"}` results in a type error if homogeneity is enforced.

**Kind:**

- A map of strings to u8s: `<{string:u8}>`
- A map of strings to a map of strings to u8: `<{string:{string:u8}}>`

(d) Tuple

```ebnf
tuple := "(", ?[expression, ","], ")" ;
tuple-struct := atom, "(", expression, ")" ;
```

A Tuple is defined using parentheses `()` and contains an ordered collection of elements, which can be of different types. 

**Semantics:**

- Ordered: The order of elements within a tuple is preserved.
- Heterogeneous: A tuple can contain elements of different types.
- Immutable: Once created, the elements in a tuple cannot be changed.

**Operations:**

- Access: Elements can be accessed by their position (zero-based index).
- Concatenation: Tuples can be combined to form a larger tuple.
- Decomposition: Tuples can be unpacked into individual variables.

**Examples:**

  ()                 
  (1)                
  (1,1,3)                
  (1,(2,3))                
  (1, true, "Hello")                 

**Edge Cases:**

- `()` represents an empty tuple.

- `(1)` is a single-element tuple, not a parenthetical expression that evaluates to `1`.

- Tuples maintain the type of each element, so `(1, "hello")` has the kind `<(f64,string)>`,, unlike sets which require homogeneity.

**Kind**

```
-- Two-tuple of u8 and string    <(u8,string)>
-- Three-tuple of u8s            <(u8,u8,u8)>
```

(e) Table

```ebnf
table := table-start
      , *(box-drawing-char | whitespace)
      , table-header
      , *(box-drawing-char | whitespace)
      , +table-row
      , *box-drawing-char
      , *whitespace
      , table-end ;
binding := identifier
      , ?kind-annotation
      , colon
      , expression
      , ?"," ;
table-column := *(space | tab)
      , expression
      , *((space | tab)
            , ?("," | table-separator)
            , *(space | tab)) ;
table-row := ?table-separator
      , *(space | tab)
      , +table-column
      , ?semicolon
      , ?new-line
      , ?(+box-drawing-char, new-line) ;
table-header := [field, +space-tab]
      , *(space | tab)
      , (bar| box-vert)
      , *whitespace ;
field := identifier, ?kind-annotation ;
empty-table := table-start
      , *whitespace
      , table-end ;
```

A Table represents a structured collection of records, where each record consists of multiple fields (columns). Tables allow organizing data in a flexible, expressive manner.
**Semantics:**

- Structured: Each record consists of ordered fields (columns).
- Heterogeneous: Fields can have different kinds (types).
- Homogeneous: Each row has a similar structure, with the same fields.
- Sparse: Tables allow missing values (denoted by `_`).

**Defining Tables:**

Tables are enclosed in `{}` and contain a header row specifying column names and kinds. The pipe \| separates the header from the data rows.

  { x<f32>  y<u8> | 
    1.2     9 
    1.3     8     }
This defines a table with two columns:

- `x<f32>`: A floating-point column.
- `y<u8>`: An unsigned 8-bit integer column.

The same table can be written in a compact, inline format using semicolons (;) to separate rows.

```
{ x<f32> y<u8> | 1.2 9; 1.3 8 }
```

Where `|` denotes the end of the header, and each row is separated by a semicolon `;`.

**Any Fields**

The `_` is the "any" kind and allows columns to contain data from mixed kinds.

  { x<_>   y<_> |
    1.2    true 
    "Hi"   8<u8>}

Here, `x` holds both floats and strings, and y holds both integers and booleans. This can be useful for dealing with data whose type is not known at compiletime.

**Sparse Tables**

When used as a value in a table, `_` indicates that a cell is missing and will be filled in later.

  { x<u8>  y<string> z<[u8]:3> |
     _      "a"       [1;2;3] 
     4      "b"          _    
     7       _        [7;8;9]  }

**Fancy Representation**

The Mech REPL prints tables using a fancy represntation, which is valid as input to a Mech program as well. The above table is equavlent to the following fancy table:

```
‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ
‚îÇ x<u8>   y<string>  z<[u8]:3> ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   _   ‚îÇ   "a"    ‚îÇ  [1;2;3]  ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   4   ‚îÇ   "b"    ‚îÇ     _     ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   7   ‚îÇ    _     ‚îÇ  [7;8;9]  ‚îÇ
‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ
```

**Kind:**

A table's kind includes the column types and table dimensions. For example, the pretty print table's kind is:

**This denotes:**

- Columns: `{ u8, string, [u8]:3 }` (a mix of an -integer, a string, and a fixed-size array).

- Shape: `3,3` (3 rows, 3 columns).

**Performance Considerations:**

Tables are more expressive and flexible than matrices, because they can support missing values and mixed types. However, they may be slower due to additional metadata and dynamic typing associated with each cell, and the unwrapping involved in accessing data.

Table columns are stored in a column matrix with unboxed value element, so operating column-wise on table values can be fast.

However, "any" kinded columns resolve to a column matrix of fully wrapped values, so they will not work with matrix operations that expect unboxed values.

A table row is equivalent to a record.

```
<{u8, string, [u8]:3}:3,3>
```

(f) Record


```ebnf
record := table-start
      , *whitespace
      , +binding
      , *whitespace
      , table-end ;
```
A Record is a collection of named fields, where each field consists of a key-value pair. Records provide a structured way to group related data while allowing heterogeneous types.

**Semantics:**

- Named Fields: Each field is identified by a unique name.
- Heterogeneous: Fields can have different types.
- Nested: Records can contain other records.

**Defining Records:**

Records are enclosed in `{}` and contain bindings of the form key: value. The type of each field can be inferred or explicitly specified.

**Examples 1: Implicitly Typed Records**

  { x: 1 y: "a", z: [1; 2; 3] }

This defines a record with three fields:

- x (implicitly an float).
- y (implicitly a string).
- z (implicitly a column matrix of floats).

**Example 2: Explicitly Typed Record**

  { x<u8>: 1, y<string>: "a", z<[u8]:3,1>: [1; 2; 3] }

Here, each field has an explicit kind:

- `x<u8>`: A `u8` integer.
- `y<string>`: A string.
- `z<[u8]:3,1>`: A fixed-size 3√ó1 matrix of `u8` integers.

**Example 3: Nested Records**

  { a: {b: 1, c: "hi"}, b: [1;2;3] }

This record contains:

- a: A nested record `{b: 1, c: "hi"}`.
- b: A columm matrix `[1;2;3]`.

**Kind Representation:**

A record's kind describes the types of its fields:

```
<{x: u8, y: string, z: [u8]:3,1}>
```

This denotes a record with:

- x: `u8`
- y: `string`
- z: `[u8]:3,1` (a 3√ó1 array of u8 values)

Comparison to Tables

- Records group related attributes of a single entity.
- Access a field on a record yields a scalar of that type, rather than a column matrix.
- A table with one row is not the same as a record, as they have to be stored differently internally.
- A table can be thought of as a vector of records.

Tables represent multiple records (rows) sharing a common structure.

6. Expressions
-------------------------------------------------------------------------------

```ebnf
expression := range-expression | formula ;
```

Expressions define computations in Mech. Most expressions operate elementwise over collections according to the rules of broadcasting.

**Broadcasting Rules:**

- Scalars expand to match the shape of collections.
- Operations between collections are elementwise when shapes are compatible.
- Higher-dimensional collections expand along singleton dimensions when necessary.
- Tables support column-wise elementwise operations but use set-based operations (e.g., unions, joins) for whole-table manipulation.

**Expression Categories:**

- Arithmetic: Addition, subtraction, multiplication, and division over scalars, vectors, and matrices.
- Matrix Operations: Matrix multiplication, transposition, and other matrix-specific operations.
- Comparison: Elementwise relational comparisons (<, >, ==, etc.).
- Logical Operations: Boolean elementwise operations (and, or, not).
- Set Operations: Union, intersection, and other set-specific operations.
- Range Expressions: Constructing sequences of values.
- Indexing: Accessing elements within collections using direct and computed indices.

(a) Formula 

```ebnf
parenthetical-term := left-parenthesis, formula, right-parenthesis ;
negate-factor := "-", factor ;

formula := l1, *(range-operator, l1) ;
add-sub-operator := add | subtract ;
l1 := l2, *(add-sub-operator, l2) ;
mul-div-operator := multiply | divide ;
matrix-operator := matrix-multiply 
      | multiply 
      | divide 
      | matrix-solve ;
l2 := l3, *(mul-div-operator | matrix-operator, l3) ;
exponent-operator := exponent ;
l3 := l4, *(exponent-operator, l4) ;
logic-operator := and 
      | or 
      | xor ;
l4 := l5, *(logic-operator, l5) ;
comparison-operator := not-equal 
      | equal-to 
      | greater-than-equal 
      | greater-than 
      | less-than-equal 
      | less-than ;
l5 := factor, *(comparison-operator, factor) ;  
factor := (parenthetical-term 
      | structure 
      | fsm-pipe 
      | function-call 
      | literal 
      | slice 
      | var), ?transpose ;
```

A formula is an expression that follows operator precedence rules and consists of arithmetic, logical, comparison, matrix, and range expressions. Expressions in formulas are evaluated according to their precedence, with higher-precedence operations being evaluated first.

**Operator Precedence:**

Operators in formulas are applied according to the following precedence, from highest to lowest:

- Parentheses - Explicit grouping of expressions.
- Negation and Logical NOT - Unary operations.
- Exponentiation - Raising to a power.
- Multiplication, Division, and Matrix Operations - Elementwise and matrix operations.
- Addition and Subtraction - Binary arithmetic operations.
- Comparison Operators - Elementwise comparisons.
- Logical Operators - and, or, xor.
- Range Operators - Used in range expressions.

**Evaluation Order and Associativity:**

- Left-to-right associativity applies to all operators, including exponentiation.
- Parentheses explicitly override precedence rules.

(a) Arithmetic

```ebnf
add       := "+" ;
subtract  := "-" ;
multiply  := "*" ;
divide    := "/" ;
exponent  := "^" ;
remainder := "%" ;
```

(b) Matrix

```ebnf
solve           := "\\" ;
dot-product     := "¬∑" ;
cross-product   := "‚®Ø" ;
matrix-multiply := "**" ;
transpose       := "'" ;
```

(c) Comparison

```ebnf
not-equal        := "!=" | "¬¨=" | "‚â†" ;    
equal            := "==" ;             
greater          := "> " ;            
less             := "< " ;            
greater-or-equal := ">=" | "‚â•"  ;       
less-or-equal    := "<=" | "‚â§"  ;       
```

(d) Logical

```ebnf
or           := "|" ;            
and          := "&" ;            
not          := "!" | "¬¨";         
exclusive-or := "xor" | "‚äï" | "‚äª" ;   
```

(e) Set

```ebnf
union := "‚à™";       
intersection := "‚à©";       
difference := "‚àñ";       
complement := "‚àÅ" | "'" ;  
subset := "‚äÜ";       
superset := "‚äá";       
proper-subset := "‚ää";       
proper-superset := "‚äã";       
element-of := "‚àà";       
not-element-of := "‚àâ";       
```

(f) Range

```ebnf
range-inclusive := "..=" ;
range-exclusive := ".." ;
```

7. Indexing
-------------------------------------------------------------------------------

```ebnf
subscript := swizzle-subscript 
      | dot-subscript-int 
      | dot-subscript 
      | bracket-subscript 
      | brace-subscript ; 
index := identifier, +subscript ;
```

(a) Slicing

```ebnf
bracket-subscript := "["
      , [(select-all | range-subscript | formula-subscript), ","]
      , "]" ;

brace-subscript := "{"
      , [(select-all | formula-subscript), ","]
      , "}" ;
formula-subscript := formula ;
range-subscript := range-expression ;
select-all := ":" ;
```

(b) Dot Index

```ebnf
dot-subscript := ".", identifier ;
dot-subscript-int := ".", integer-literal ;
```

(c) Swizzle

```ebnf
swizzle-subscript := "."
      , identifier
      , "," 
      , [identifier, ","] ;
```

8. Statements
-------------------------------------------------------------------------------

```ebnf
statement := variable-define 
      | variable-assign 
      | enum-define 
      | fsm-declare 
      | kind-define ;
```

(a) Variable Define

```ebnf
define-operator := ":=" ;
variable-define := ?tilde, var
      , ¬¨assign-operator
      , define-operator
      , expression ;
```

(b) Variable Assign

```ebnf
assign-operator := "=";
variable-assign := slice-ref
      , ¬¨define-operator
      , assign-operator
      , expression ;
```

(c) Op-Assign

```ebnf
add-assign-operator := "+=";
sub-assign-operator := "-=";
mul-assign-operator := "*=";
div-assign-operator := "/=";
exp-assign-operator := "^=";
op-assign-operator := add-assign-operator 
      | sub-assign-operator 
      | mul-assign-operator 
      | div-assign-operator 
      | exp-assign-operator ;
op-assign := slice-ref
      , ¬¨define-operator
      , op-assign-operator
      , expression ;
```

(c) Enum Define

```ebnf
enum-define := "<"
      , identifier, ">"
      , define-operator
      , [enum-variant, enum-separator];
enum-variant := ?grave
      , identifier
      , ?enum-variant-kind ;
enum-variant-kind := "("
      , kind-annotation
      , ")" ;
```

(d) Kind Define

```ebnf
kind-define := "<"
      , identifier
      , ">"
      , define-operator
      , kind-annotation ;
```

9. Functions
-------------------------------------------------------------------------------

(a) Function Define

```ebnf
function-define := identifier
      , "("
      , ?[function-arg,list-separator]
      , ")"
      , "="
      , (function-out-args | function-out-arg)
      , define-operator
      , [statement, (+whitespace | statement-separator)]
      , "." ;
function-out-args := "("
      , [function-arg, list-separator]
      ,")" ;      
function-out-arg := function-arg ;
function-arg := identifier, kind-annotation ;
argument-list := "(", ?[(call-arg-with-biding | call-arg), ","], ")" ;
```

(b) Function Call

```ebnf
function-call := identifier, argument-list ;
call-arg-with-binding := identifier
      , colon
      , expression ;
call-arg := expression ;
var := identifier, ?kind-annotation ;
```

10. State Machines
-------------------------------------------------------------------------------

```ebnf
fsm := "#"
      , identifier
      , ?argument-list
      , ?kind-annotation ;
```

(a) Operators

```ebnf
output-operator := "=>" ;
transition-operator := "->" ;
async-transition-operator := "~>" ;
guard-operator := "|" 
      | "‚îÇ" 
      | "‚îú" 
      | "‚îî" ;
```

(b) Specification

```ebnf
fsm-specification := "#"
      , identifier
      , "("
      , ?[var, ","]
      , ")"
      , ?output-operator
      , ?kind-annotation, define-operator, +fsm-state-definition, "." ;
fsm-tuple-struct := grave
      , identifier
      , "("
      , [fsm-pattern, ","]
      , ")" ;
fsm-state-definition := guard-operator
      , grave
      , identifier
      , ?fsm-state-definition-variables ;
fsm-state-definition-variables := "("
      , ?[var, list-separator]
      , ")" ;
fsm-pipe := fsm-instance, *(fsm-state-transition | fsm-async-transition | fsm-output) ;
fsm-declare := fsm
      , define-operator
      , fsm-pipe ;
fsm-instance := "#"
      , identifier
      , ?fsm-args ;
fsm-args := "("
      , ?[(call-arg-with-binding | call-arg), list-separator]
      , ")" ;
```

(c) Implementation

```ebnf
fsm-implementation := "#"
      , identifier
      , "("
      , ?[identifier, list-separator]
      , ")"
      , transition-operator
      , fsm-pattern
      , *whitespace
      , +fsm-arm
      , "." ;
fsm-arm := *comment
      , (fsm-transition | fsm-guard-arm)
      , *whitespace ;
fsm-guard-arm := *comment
      , fsm-pattern
      , +fsm-guard ;
fsm-guard := guard-operator
      , fsm-pattern
      , +(fsm-statement-transition | fsm-state-transition | fsm-output | fsm-async-transition | fsm-block-transition) ;
fsm-transition := *comment
      , fsm-pattern
      , +(fsm-statement-transition | fsm-state-transition | fsm-output | fsm-async-transition | fsm-block-transition) ;
fsm-state-transition := transition-operator, fsm-pattern ;
fsm-async-transition := async-transition-operator, fsm-pattern ;
fsm-statement-transition := transition-operator, statement ;
fsm-block-transition := transition-operator
      , left-brace
      , +mech-code
      , right-brace ;
fsm-output := output-operator, fsm-pattern ;
fsm-pattern := fsm-tuple-struct 
      | wildcard 
      | formula ;
wildcard := "*" ;
```


11. Mech Programs
-------------------------------------------------------------------------------

```ebnf
mech := program | statement ;
```

(a) Programs

```ebnf
program := ?title, body ;
body := +section ;
```

(b) Sections

```ebnf
section-element := mech-code 
      | unordered-list 
      | comment 
      | paragraph 
      | code-block 
      | sub-section ;
sub-section-element := comment 
      | unordered-list 
      | mech-code 
      | paragraph 
      | code-block;
sub-section := alpha-subtitle, *sub-section-element ;
section := ?ul-subtitle, +section-element ;
```

12. Mechdown
-------------------------------------------------------------------------------

(a) Markdown

```ebnf
title := +text
      , new-line
      , +"="
      , *(space|tab)
      , *whitespace ;
subtitle := +digit-token
      , "."
      , *space
      , +text
      , new-line
      , +"-"
      , *(space|tab)
      , new-line
      , *(space|tab)
      , *whitespace ;
number-subtitle := *(space|tab)
      , "("
      , integer-literal
      , ")"
      , +(space|tab)
      , +text
      , *(space|tab)
      , *whitespace ;
alpha-subtitle := *(space|tab)
      , "(", alpha, ")"
      , +(space|tab)
      , +text
      , *(space|tab)
      , *whitespace ;
paragraph-element := +(¬¨define-operator, text) ;
paragraph := paragraph-starter, *paragraph-element ;
unordered-list := +list-item, ?new-line, *whitespace ;
list-item := dash
      , +space
      , paragraph
      , *new-line ;
code-block := (grave, grave, grave), new-line, any, (grave, grave, grave), new-line, *whitespace ;
```

(b) Mech Extensions

```ebnf
mech-code := mech-code-alt, ("\n" | ";" | comment) ;
```

13. Notation
-------------------------------------------------------------------------------

The grammar is specified using extended Extended Backus-Naur Form (EBNF):

| Symbol   | Meaning  | Semantics                     |
|----------|----------|-------------------------------|
| `"abc"`  | terminal | string literal "abc"          |
| `p1, p2` | sequence | `p1` followed by `p2`         |
| `p1 | p2`| choice   | `p1` or `p2`                  |
| `[p, q]` | list     | list of `p` deliniated by `q` |
|   `*p`   | repeat 0 | `p` for 0 or more times       |
|   `+p`   | repeat 1 | `p` for 1 or more times       |
|   `?p`   | optional | `p` for 0 or 1 time           |
|   `>p`   | peek     | `p`; do not consume input     |
|   `¬¨p`   | not      | does not match `p`            |
|  `(...)` | group    | incrase precedence            |


The grammar grammar:

```ebnf
grammar := +rule ;
identifier := alpha-token, *(alpha-token | digit-token | dash) ;
rule := identifier
      , ":="
      , expression
      , ";" ;
expression := term, *( "|", term ) ;
term := factor, *( ",", factor ) ;
definition := identifier ;
repeat0 := "*", factor ;
repeat1 := "+", factor ;
optional := "?", factor ;
peek := ">", factor ;
not := "¬¨", factor ;
list := "[", expression, terminal, "]" ;
factor := repeat0 
      | repeat1 
      | optional 
      | peek 
      | not 
      | list
      | group 
      | definition 
      | terminal ;
group := "(", expression, ")" ;
terminal := quote, +any-token, quote ;
```
